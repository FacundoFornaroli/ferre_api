ğŸ—ï¸ FUNDAMENTOS DE LA ARQUITECTURA
1. Â¿QUÃ‰ ES FASTAPI Y POR QUÃ‰ LO USAMOS?
FastAPI es un framework moderno de Python para crear APIs web. Es como un "constructor" que nos permite crear servicios web de forma rÃ¡pida y eficiente.
Â¿Por quÃ© FastAPI?
âš¡ Muy rÃ¡pido - comparable a NodeJS y Go
   ValidaciÃ³n automÃ¡tica de datos
ğŸ“š DocumentaciÃ³n automÃ¡tica (Swagger/OpenAPI)
ğŸ›¡ï¸ Seguro por defecto
   Python moderno con type hints
Â¿CuÃ¡ndo usarlo?
Cuando necesitas crear una API REST
Para conectar frontend con backend
Cuando quieres documentaciÃ³n automÃ¡tica
Para microservicios
2. Â¿QUÃ‰ SON LOS MODELOS (models.py)?
Los modelos son como "plantillas" que representan las tablas de tu base de datos en cÃ³digo Python.
class Categorias(Base):
    __tablename__ = "Categorias"
    ID_Categoria = Column(Integer, primary_key=True, index=True)
    Nombre = Column(String(100), nullable=False)

Â¿Por quÃ© los necesitamos?
ğŸ—„ï¸ Mapeo objeto-relacional (ORM)
ğŸ”’ ValidaciÃ³n de datos automÃ¡tica
ğŸ” Consultas mÃ¡s seguras que SQL directo
ğŸ› ï¸ Mantenimiento mÃ¡s fÃ¡cil
Â¿CuÃ¡ndo usarlos?
Siempre que trabajes con bases de datos
Para evitar errores de SQL
Para hacer consultas mÃ¡s legibles
3. Â¿QUÃ‰ SON LOS SCHEMAS (schemas.py)?
Los schemas son como "contratos" que definen quÃ© datos se pueden enviar y recibir en la API.

class CategoriaCreate(CategoriaBase):
    pass

class Categorias(CategoriaBase):
    ID_Categoria: int
    class Config:
        from_attributes = True


Â¿Por quÃ© los necesitamos?
âœ… ValidaciÃ³n automÃ¡tica de datos
ğŸ“ DocumentaciÃ³n automÃ¡tica en Swagger
ğŸ”’ Seguridad - solo los campos definidos se procesan
   Claridad - sabes exactamente quÃ© datos esperar
Â¿CuÃ¡ndo usarlos?
Para todas las rutas de la API
Para validar datos de entrada
Para definir respuestas de la API
   PATRÃ“N CRUD - EL FUNDAMENTO DE LAS RUTAS
Â¿QUÃ‰ ES CRUD?
CRUD significa Create, Read, Update, Delete (Crear, Leer, Actualizar, Eliminar). Es el patrÃ³n bÃ¡sico para manejar datos.

# CREATE - Crear
@app.post("/categorias/")
def crear_categoria(categoria: schemas.CategoriaCreate, db: Session = Depends(get_db)):
    db_categoria = models.Categorias(**categoria.dict())
    db.add(db_categoria)
    db.commit()
    return db_categoria

# READ - Leer
@app.get("/categorias/")
def obtener_categorias(db: Session = Depends(get_db)):
    return db.query(models.Categorias).all()

# UPDATE - Actualizar
@app.put("/categorias/{categoria_id}")
def actualizar_categoria(categoria_id: int, categoria: schemas.CategoriaUpdate, db: Session = Depends(get_db)):
    # LÃ³gica de actualizaciÃ³n

# DELETE - Eliminar
@app.delete("/categorias/{categoria_id}")
def eliminar_categoria(categoria_id: int, db: Session = Depends(get_db)):
    # LÃ³gica de eliminaciÃ³n

Â¿Por quÃ© este patrÃ³n?
ğŸ¯ EstandarizaciÃ³n - todos saben quÃ© esperar
   Consistencia - mismo patrÃ³n para todas las tablas
   DocumentaciÃ³n clara - fÃ¡cil de entender
  ï¸ Mantenimiento - fÃ¡cil de mantener
ğŸ”§ COMPONENTES CLAVE EXPLICADOS
1. DEPENDENCIAS (Depends)

def get_db():
    db = SessionLocal()
    try:
        yield db
    finally:
        db.close()

@app.get("/categorias/")
def obtener_categorias(db: Session = Depends(get_db)):
    # db se inyecta automÃ¡ticamente

Â¿Por quÃ©?
ğŸ”„ InyecciÃ³n de dependencias automÃ¡tica
ğŸ§¹ Limpieza automÃ¡tica de recursos
ğŸ”’ Seguridad - cada request tiene su propia sesiÃ³n
ğŸ¯ ReutilizaciÃ³n - no repetir cÃ³digo
2. MANEJO DE ERRORES

@app.get("/categorias/{categoria_id}")
def obtener_categoria(categoria_id: int, db: Session = Depends(get_db)):
    categoria = db.query(models.Categorias).filter(models.Categorias.ID_Categoria == categoria_id).first()
    if not categoria:
        raise HTTPException(status_code=404, detail="CategorÃ­a no encontrada")
    return categorÃ­a

Por quÃ©?
ğŸš¨ Respuestas consistentes de error
ğŸ“± Frontend puede manejar errores apropiadamente
ğŸ” Debugging mÃ¡s fÃ¡cil
ğŸ‘¥ Experiencia de usuario mejor
3. VALIDACIÃ“N AUTOMÃTICA

class ProductosCreate(ProductosBase):
    @validator('Precio')
    def validar_precio(cls, v):
        if v < 0:
            raise ValueError('El precio debe ser mayor o igual a 0')
        return v

Por quÃ©?
  ï¸ Datos seguros - no se guardan datos invÃ¡lidos
ğŸ¯ Reglas de negocio aplicadas automÃ¡ticamente
   DocumentaciÃ³n clara de validaciones
ğŸš¨ Errores tempranos - se detectan antes de llegar a la BD
   FLUJO DE UNA PETICIÃ“N HTTP
Â¿CÃ³mo funciona todo junto?
Cliente hace peticiÃ³n â†’ GET /categorias/
FastAPI recibe la peticiÃ³n â†’ Busca la funciÃ³n correspondiente
InyecciÃ³n de dependencias â†’ get_db() se ejecuta automÃ¡ticamente
ValidaciÃ³n de parÃ¡metros â†’ FastAPI valida automÃ¡ticamente
EjecuciÃ³n de la funciÃ³n â†’ Tu cÃ³digo se ejecuta
Consulta a la base de datos â†’ SQLAlchemy ejecuta la consulta
ValidaciÃ³n de respuesta â†’ Pydantic valida los datos de salida
Respuesta al cliente â†’ JSON con los datos

# 1. Cliente pide: GET /categorias/
# 2. FastAPI encuentra esta funciÃ³n:
@app.get("/categorias/", response_model=List[schemas.Categorias])
def obtener_categorias(db: Session = Depends(get_db)):
    # 3. get_db() se ejecuta automÃ¡ticamente
    # 4. Se valida que db sea una sesiÃ³n vÃ¡lida
    categorias = db.query(models.Categorias).all()
    # 5. Se ejecuta la consulta SQL
    # 6. Se valida que el resultado sea List[Categorias]
    return categorias
    # 7. Se devuelve JSON al cliente

   CUÃNDO USAR CADA TIPO DE RUTA
GET - Para leer datos
@app.get("/categorias/")  # Listar todos
@app.get("/categorias/{id}")  # Obtener uno especÃ­fico
@app.get("/categorias/buscar/{nombre}")  # BÃºsquedas

POST - Para crear datos
@app.post("/categorias/")  # Crear nuevo registro

PUT - Para actualizar datos
@app.put("/categorias/{id}")  # Actualizar registro existente

DELETE - Para eliminar datos
@app.delete("/categorias/{id}")  # Eliminar registro

ğŸ” RUTAS ADICIONALES - Â¿POR QUÃ‰ LAS NECESITAMOS?

# Ruta adicional para obtener inventario por producto
@app.get("/inventario/producto/{producto_id}")
def obtener_inventario_por_producto(producto_id: int, db: Session = Depends(get_db)):
    inventario = db.query(models.Inventario).filter(models.Inventario.ID_Producto == producto_id).all()
    return inventario

Â¿Por quÃ© rutas adicionales?
ğŸ¯ Casos de uso especÃ­ficos del negocio
ğŸ“Š Reportes y consultas especializadas
ğŸ” BÃºsquedas avanzadas
ğŸ“± OptimizaciÃ³n para el frontend